#!/usr/bin/env python 

# Standard python modules
import getpass
import os
import subprocess
import sys
import re

# Local modules
import data
from   error    import ErrorMessage, NotAWorktree, AmbiguousPartialWorktree
from   misc     import FixPath
from   run      import FilterCommand

reIntel = re.compile('(^||/)Intel', re.IGNORECASE)
reAMD   = re.compile('(^||/)Amd', re.IGNORECASE)
reArm   = re.compile('(^||/)Arm', re.IGNORECASE)

# Base class for Version Control System (VCS)  
class VCS:

  # Files with the following extensions are considered build artefacts and not displayed in status
  BUILD_ARTIFACT_EXTENSIONS = ( '.bin', '.cap', '.checksum', '.efi', '.fd', '.hdr', '.lib', '.log', '.rom' )

  # Files with the following substrings in them are considered build artefacts and not displayed in status
  BUILD_ARTIFACT_SUBSTRINGS = ('AutoGenerated', 'RestrictedBinary', 'timer.txt')

  # Files with the following extensions are considered source files and are displayed in status
  SOURCE_FILE_EXTENSIONS    = ( '.asi', '.asl', '.bat', '.c', '.cer', '.cpp', '.dec', '.dsc', '.h', '.hpp', '.inc', '.inf', '.ini', '.uni', '.xml' )

  # Constructor
  # name:   Name of the VCS
  # base:   Base directory of the source code tree
  # sts:    Status command
  # fmt:    Format to be used in status output
  # returns nothing
  def __init__(self, name, base, sts, fmt):
    # Save givens
    self.__name   = name
    self.__base   = base
    self.__status = sts
    self.__format = fmt

  ###################
  # Private methods #
  ###################

#  # Determine if a given file is one that has been pruned
#  # filename - filename to check
#  # returns True if file as a build artifact, False otherwise
#  def __isPrunedFile(self, filename):
#    # Extract important portion of the path
#    if filename[0] == '"': filename = filename[1:len(filename)-1]
#    path = os.path.dirname(filename)
#    # Check for pruned CPU vendor file
#    vendor = data.GetSetting(data.lcl, 'vendor', '{0} init')
#    # Look for pruned CPU vendor files
#    for cpuType, regex in (('intel', reIntel), ('amd', reAMD), ('arm', reArm)):
#      if vendor != cpuType:
#        result = regex.search(path)
#        if result:
#          return True
#    # Not a pruned file
#    return False

  # Determine if a given file is a build artifact
  # filename: filename to check
  # returns   True if file as a build artifact, False otherwise
  def __isBuildArtifact(self, filename):
    # Handle obviously autogenrated files
    for substring in self.BUILD_ARTIFACT_SUBSTRINGS:
      if substring in filename: return True
    # Get name and extension
    name, ext = os.path.splitext(filename)
    # Handle extensions that are usually build artifacts
    return (ext.lower() in self.BUILD_ARTIFACT_EXTENSIONS)

  # Determine if a given file is a source file
  # filename: Filename to check
  # returns   True if file is a Source file, False otherwise
  def __isSourceFile(self, filename):
    # Get name and extension
    name, ext = os.path.splitext(filename)
    # Handle extensions that are usually source files
    return (ext.lower() in self.SOURCE_FILE_EXTENSIONS)
  

  # Execute a command
  # cmd:    Command to execute
  # hnd:    Handler for command output
  # returns return code from the command
  def __run(self, cmd, hnd = None):
    # Switch to execution directory
    saved = os.getcwd()
    os.chdir(self.__base)
    # Execute the command
    process = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    # Process command output
    for line in process.stdout.readlines():
      # Call appropriate handler
      if type(line) is bytes:
        line = line.decode('utf-8')
      if hnd: input = hnd(line)
      else:   input = self.Line(line)
      # See if any input was returned
      if input:
        # Process the input
        for inp in input: process.stdin.writeline(inp)
    # Switch back
    os.chdir(saved)
    # Return resulting error code
    return process.returncode

  # Begin status processing
  # returns nothing
  def __statusBegin(self):
    self.__changes = []

  # Start status processing
  # all:    True if unversioned files are to be processed, False otherwise
  # returns nothing
  def __statusEnd(self, all):
    # Build output list
    lst = []
    for state, path in self.__changes:
      if all or not state == 'Unversioned':
        lst.append(self.__format.format(state, path))
      # Anything to show  
    if len(lst) == 0:
      print('\nNothing to show!')
    else:
      # Print header
      print('\n' + self.__format.format('State', 'Path'))
      print(self.__format.format('-----', '----'))
      # Show items
      for item in lst: print(item)

  ###########
  # Getters #
  ###########

  # Get the base directory of the source code tree
  # returns VCS base directory
  def Base(self):
    return self.__base

  # Get the name of the VCS
  # returns VCS name
  def Name(self):
    return self.__name

  # Get the status command for the VCS
  # returns VCS status
  def Status(self):
    return self.__status

  # Get the status formnt for the VCS
  # returns VCS format string
  def Format(self):
    return self.__format

  ##################
  # Public methods #
  ##################

  # Handle line of output
  # returns nothing or list of lines of input
  def Line(self, line):
    sys.stdout.write(line)
    return None

  # Process a line from the status command
  # line:   Line to process
  # returns nothing
  # MUST BE OVERRIDDEN IN SUBCLASS
  def StatusLine(self, line):
    raise NotImplementedError

  # Add change to perform on next commit
  # item:   Item to which the change is targeted
  # add:    True if action is add/update, False if action is delete 
  # returns 0 on success, non-zero otherwise
  def Action(self, item, add = True):
    raise NotImplementedError

  # Commit changes (may be a local)
  # returns 0 on success, non-zero otherwise
  def Commit(self):
    raise NotImplementedError

  # Fetch upstream changes
  # returns 0 on success, non-zero otherwise
  def Fetch(self, revision = None):
     raise NotImplementedError

  # Get log information
  # rev1:   First rev for which log information is desired
  #         ('' implies base revision)
  # rev2:   Last  rev for which log information is desired
  #         ('' implies only 1 revision)
  # returns 0 on success, non-zero otherwise
  def Log(self, rev1 = '', rev2 = ''):
     raise NotImplementedError

  # Push local changes upstream
  # returns 0 on success, non-zero otherwise
  def Push(self):
     raise NotImplementedError

  # Get status of repository
  # all:    True indicates include unversioned file, False otherwise
  # returns 0 on success, non-zero otherwise
  def Status(self, all):
    # Begin status processing
    self.__statusBegin()
    # Process status command
    rc = self.__run(self.__status, self.StatusLine)
    # End status processing
    self.__statusEnd(all)
    return rc

# Class for SVN Version Control System (VCS)
class svnVCS(VCS):

  # Different states a file may have
  State = { 'A': 'Added',
            'D': 'Deleted',
            'M': 'Modified',
            'R': 'Replaced',
            'C': 'Conflicted',
            '?': 'Unversioned',
            '!': 'Missing',
            '~': 'TypeChange',
          }

  # Constructor
  # base:   Base of the source code tree
  # returns nothing
  def __init__(self, base):
    VCS.__init__(self, 'svn', base, 'svn status', '{0:<12} {1}')

  # Handle line of output
  # line:  Line of output
  # return None or list of lines of input
  def Line(self, line):
    # Asssume no user or password
    input = []
    # Show output
    sys.stdout.write(line)
    # See if there is an authentication challenge
    if line.startswith('Username:'):
      # Get username
      input.append(raw_input())
    elif line.startswith('Password for'):
      # Get password
      input.append(getpass.getpass())
    # Return resulting input
    return None if len(input) == 0 else input

  # Process a line from the status command
  # line:   Line to process
  # returns nothing
  def StatusLine(self, line):
    # Make sure line is not empty
    if line:
      flags, filename = line.strip().split(' ', 1)
      state = self.State[flags]
      name  = filename.strip()
      # Don't include build artifacts
      if self._VCS__isBuildArtifact(name): return
      # Don't include unversioned items
      if flags == '?':
         # Don't include files that aren't source files
        if not self._VCS__isSourceFile(name): return
      # Include this item
      self._VCS__changes.append((state, name))

  # Add change to perform on next commit
  # item:   Item to which the change is targeted
  # add:    True if action is add/update, False if action is delete 
  # returns 0 on success, non-zero otherwise
  def Action(self, item, add = True):
    action = 'add' if add else 'rm'
    return self._VCS__run('svn {0} {1}'.format(action, item))

  # Commit changes (may be a local)
  # returns 0 on success, non-zero otherwise
  def Commit(self, msg):
    return self._VCS__run('svn commit --force-interactive'.format(msg))

  # Fetch upstream changes
  # revision: Revision to fetch
  # returns   0 on success, non-zero otherwise
  def Fetch(self, revision = None):
    return self._VCS__run('svn update {0} --force-interactive'.format(revision if revision else ''))

  # Get log information
  # rev1:   First rev for which log information is desired
  #         ('' implies base revision)
  # rev2:   Last  rev for which log information is desired
  #         ('' implies only 1 revision)
  # returns 0 on success, non-zero otherwise
  def Log(self, rev1 = '', rev2 = ''):
    # Supply defaults (if needed)
    r1 = rev1 if rev1 else 'BASE'
    r2 = rev2 if rev2 else 'HEAD'
    # Get the log output
    return self._VCS__run('svn log -r {0}:{1} --force-interactive'.format(r1, r2))

  # Push local changes upstream
  # returns 0 on success, non-zero otherwise
  def Push(self):
    # SVN does not have the concept of a "push"
    return 0

# Class for git Version Control System (VCS)
class gitVCS(VCS):

  # Different states a file may have
  State = {' ': 'None',
           'A': 'Added',
           'C': 'Copied',
           'D': 'Deleted',
           'M': 'Modified',
           'R': 'Renamed',
           'U': 'Unmerged',
          }

  # Constructor
  # base:   Base of the source code tree
  # returns nothing
  def __init__(self, base):
    VCS.__init__(self, 'git', base, 'git status --porcelain=v1', '{0:<18} {1}')

  # Handle line of output
  # return None or list of lines of input
  def Line(self, line):
    # Asssume no user or password
    input = []
    # Show output
    sys.stdout.write(line)
    # See if there is an authentication challenge
    if line.startswith('Username:'):
      # Get username
      input.append(raw_input())
    elif line.startswith('Password for'):
      # Get password
      input.append(getpass.getpass())
    # Return resulting input
    return None if len(input) == 0 else input

  # Process a line from the status command
  # line:   Line to process
  # returns nothing
  def StatusLine(self, line):
    if line:
      # Get file status
      flags = line[0:2]
      # Don't include ignored files
      if not flags == '!!':
        # Get filename
        name = line[3:].strip()
        # Don't include files for other platform packages or CPUs
#        if self._VCS__isPrunedFile(name): return
        # Don't include build artefacts
        if self._VCS__isBuildArtifact(name): return
        # Is it an unversioned file
        if flags == '??':
          # Only include unversioned source files
          if not self._VCS__isSourceFile(name): return
          state = 'Unversioned'
        else:
          state = '{0}-{1}'.format(self.State[flags[0]], self.State[flags[1]])
      self._VCS__changes.append((state, name))

  # Add change to perform on next commit
  # item:   Item to which the change is targeted
  # add:    True if action is add/update, False if action is delete 
  # returns 0 on success, non-zero otherwise
  def Action(self, item, add = True):
    action = 'add' if add else 'rm'
    return self._VCS__run('git {0} {1}'.format(action, item))

  # Commit changes (may be a local)
  # returns 0 on success, non-zero otherwise
  def Commit(self, msg):
    return self._VCS__run('git commit -m "{0}"'.format(msg))

  # Fetch upstream changes
  # returns 0 on success, non-zero otherwise
  def Fetch(self, revision = None):
    return self._VCS__run('git fetch {0}'.format(revision if revision else ''))

  # Get log information
  # rev1:   First rev for which log information is desired
  #         ('' implies base revision)
  # rev2:   Last  rev for which log information is desired
  #         ('' implies only 1 revision)
  # returns 0 on success, non-zero otherwise
  def Log(self, rev1 = '', rev2 = ''):
    raise NotImplementedError

  # Push local changes upstream
  # returns 0 on success, non-zero otherwise
  def Push(self):
    return self._VCS__run('git push')

# Class for handling VCS information
class VCSInfo:

  # Constructor
  # vcs:     VCS object associated with path
  # isRepo:  True if a repository is needed, False if a worktree is needed
  # isListed: True if path is in repository or worktree list, False otherwise
  def __init__(self, vcs, isRepo = False, isListed = False):
    # Save givens
    self.__vcs    = vcs
    self.__isrepo = isRepo
    self.__listed = isListed
    base          = vcs.Base()
    self.__branch = None
    # Handle repo
    if isRepo:
      self.__repo = base
    else:
      self.__branch = GetBranchFromWorktree(base)
      self.__repo   = GetRepoFromWorktree(base)

  ###########
  # Getters #
  ###########

  # Get VCS
  # retruns VCS
  def VCS(self):
    return self.__vcs

  # Determine whether or not this is a repository
  # returns True if this is a repository, False if it is worktree 
  def IsRepo(self):
    return self.__isrepo

  # Determine whether or not this is a listed repository
  # returns True if this is listed, False otherwise 
  def IsListed(self):
    return self.__listed

  # Get the repository path
  # returns repository path
  def Repo(self):
    return self.__repo

  # Get the branch the repository is using
  # returns repository branch
  def Branch(self):
    return self.__branch

#####################
# Private functions #
#####################

# See if VCS is found in the list
# lst:    List to check
# base:   VCS directory for which to look
# returns True if VCS directory is in the list, False otherwise
def __FoundInList(lst, base):
  found = False   # Assume not attached
  # Loop through attached items
  for item in lst:
    # Is it in the list?
    if item == base:
      # Yes, done!
      found = True
      break
  # Return results
  return found

# See if VCS is attached where VCS can be only part of the base directory
# lst:    List of avaialble repositories or worktrees
# base:   Partial base directory to check
# kind:   'either'     looking for a repository or a worktree
#         'repository' looking for a repository
#         'worktree'   looking for a worktrees
# returns VCS if matching item if attached, None otherwise
def __DetectPartialAttached(lst, base, kind):
  message = 'repository or worktree' if kind == 'either' else kind
  result  = None   # Assume no match
  found   = []     # Start with empty list
  # Loop through attached items
  for item in lst:
    # Is it in the list?
    if base in item:
      # Yes, save it
      found.append(item)
  # Handle what was found
  cnt = len(found)
  if cnt > 1:
    # Too many found
    ErrorMessage('{0} name is ambiguous: {1}'.format(message, base))
    # DOES NOT RETURN
  elif cnt == 1:
    # Only one found
    result = found[0]
  # Return results
  return result

# Find root of a VCS directory from a full path
# lst:    List of attached VCS items
# base:   Full path to check for VCS
# returns if base is in a repository: VCSInfo with isRepo = True
#         if base is in a worktree:   VCSInfo with isRepo = False
#         if base is in neither:      None
def __FindVCS(lst, base):
  info = None   # Assume neither
  # Look for git, or svn VCS
  for dir in ('.git', '.svn'):
    # See if VCS directory exists
    path = os.path.join(base, dir)
    if os.path.exists(path):
      # For repos path is directory, for worktrees path is a file
      isRepo = os.path.isdir(path)
      vcs    = svnVCS(base) if dir == '.svn' else gitVCS(base)
      info   = VCSInfo(vcs, isRepo, __FoundInList(lst, base))
      break
  else:
    # Try up one level
    oneup = os.path.abspath(os.path.join(base, '..'))
    if not oneup == os.path.abspath(base):
      info = __FindVCS(lst, oneup)
  # Return results
  return info

# No matching item could be located
# given: Full of partial path that could not be matched
# repo:  True  if a repository was expected
#        False if a worktree   was expected
# DOES NOT RETURN
def __NoMatch(msg, given):
  ErrorMessage('Unable to find matching {0}: {1}'.format(msg, given))
  # DOES NOT RETURN

# Check to see if proper repository or worktree was found
# given:  Full of partial path that was used
# info:   Information about full or partial path
# kind:   'either'     a repository or a worktree is expected
#         'repository' a repository               is expected
#         'worktree'   a                 worktree is expected
# returns nothing if checks passed, DOES NOT RETURN otherwise
def __CheckExpected(given, info, kind):
  if kind == 'repository':
    # A repository was expected
    if info:
      if not info.IsRepo():
        # A worktree was found
        ErrorMessage('Expected a repository but found a worktree: {0}'.format(given))
        # DOES NOT RETURN
    else:
      # Repository not detected
      ErrorMessage('Not a repository: {0}'.format(given))
      # DOES NOT RETURN
  elif kind == 'worktree':
    # A worktree is expected
    if info:
      if info.IsRepo():
        # A repository was found
        ErrorMessage('Expected a worktree but found a repository: {0}'.format(given))
        # DOES NOT RETURN
    else:
      # Worktree not detected
      ErrorMessage('Worktree does not exist: {0}'.format(given))
      # DOES NOT RETURN
  else:
    if not info:
      # Worktree not detected
      ErrorMessage('Repository or worktree does not exist: {0}'.format(given))
      # DOES NOT RETURN

####################
# Public functions #
####################

# Updates global repositories value
# returns nothing
def UpdateRepos():
  repositories = ';'.join(data.gbl.repos)
  data.gbl.SetItem('repositories', repositories)
  print('data.gbl.repositories = {0}'.format(repositories))

# Get VCS information from full or partial path
# lst:    List of repositories or worktrees
# given:  Full or partial path
# kind:   'either'     allows repositories or worktrees
#         'repository' allows only repositories  (generates error otherwise)
#         'worktree'   allows only worktrees     (generates error otherwise)
# listed: True to generate error if is not in given list, False otherwise
# returns VCSInfo for repository or worktree if found or None if not found
def GetVCSInfo(lst, given, kind, listed):
  info = None   # Assume not found
  msg  = 'repository or worktree' if kind == 'either' else kind
  # See if it is a full path
  abs = os.path.abspath(given).lower()
  if os.path.isdir(abs):
    # It is a full path, get its information (if any)
    info = __FindVCS(lst, abs)
  else:
    # Handle partial path
    path = __DetectPartialAttached(lst, given.lower(), kind)
    # If found, get its information (if any)
    if path:
      info = __FindVCS(lst, path)
  # Make sure expected result were acheived
  # (DOES NOT RETURN if expected results were not acheived)
  if info:
    __CheckExpected(given, info, kind)
    # Does it need to be listed
    if listed and info:
      if not info.IsListed():
        # Not found in list
        ErrorMessage('Could not find {0} in list: {1}'.format(msg, given))
        # DOES NOT RETURN
  return info

# Repository was not defined
# how:    How to specify repository on the command line
# DOES NOT RETURN
def UndefinedRepo(how = 'supply repo argument'):
  ErrorMessage('Repository not given use ({0} or "{1} select <repo>" command)'.format(how, data.gbl.program))
  # DOES NOT RETURN

# Get repository
# how:    How to specify repository on the command line
# repo:   Path to potential repository
# returns full path of repo, DOES NOT RETURN otherwise
def GetRepo(how = 'supply repo argument', repo = None):
  # See if global setting for repo is needed
  if not repo:
    # Get repo from global settings
    path = data.gbl.repo
    # Make sure global repo setting is defined
    if data.gbl.repo == None:
      UndefinedRepo(how)
      # DOES NOT RETURN
  else:
    # Use passed in value for repo
    path = repo
  # Find repo from full or partial path
  info = GetVCSInfo(data.gbl.repos, path, 'repository', True)
  path = info.VCS().Base()
  print('Indicated repository: {0}'.format(path))
  return path

# Worktree could not be determined
# how:    How to specify worktree on the command line
# DOES NOT RETURN
def UndefinedWorktree(how = 'supply worktree argument'):
  ErrorMessage('Worktree not given ({0} or "{1} switch <worktree>" command)'.format(how, data.gbl.program))
  # DOES NOT RETURN

# Get worktree
# prms: Parameters from the command line
# how:  How to specify worktree on the command line
# idx:  Index of worktree in prms array
# return full path of worktree and VCS info, DOES NOT RETURN otherwise
def GetWorktree(prms, how = 'supply worktree argument', idx = 0):
  if len(prms) <= idx:
    worktree = data.gbl.worktree
    if worktree == None:
      UndefinedWorktree(how)
      # DOES NOT RETURN
  else:
    worktree = prms[idx]
  # Find worktree from full or partial path
  info = GetVCSInfo(data.gbl.worktrees, worktree, 'worktree', True)
  # DOES NOT RETURN if a worktree could not be found)
  worktree = info.VCS().Base()
  print('Indicated worktree: {0}'.format(worktree))
  return worktree, info

# Gets the branch on wich a worktree is based
# base: Base directory of the worktree
# returns Branch on which worktree is based
def GetBranchFromWorktree(base):
   branch = None
   def FindBranch(line):
     nonlocal branch
     # Convert bytes to string (is needed)
     if isinstance(line, bytes): line = line.decode('utf-8')
     # The active branch is preceded by the '*' character
     if line.strip().startswith('*'):
       # Extract the branch from the line
       branch = line.split(' ')[1].strip()
   result = FilterCommand('git branch', FindBranch, base)
   return branch

# Gets the branch on wich a worktree is based
# base: Base directory of the worktree
# returns Branch on which worktree is based
def DoesBranchExist(repo, branch):
   found = False
   def FindBranch(line):
     nonlocal found
     # Convert bytes to string (is needed)
     if isinstance(line, bytes): line = line.decode('utf-8')
     result = re.match('. {0}'.format(branch), line.strip())
     if result:
       found = True
   FilterCommand('git branch', FindBranch, repo, branch)
   return found

# Gets path to repository from which a worktree was created
# base: Base directory of the worktree
# returns Repository from which a worktree was created, DOES NOT RETURN  otherwise
def GetRepoFromWorktree(base):
  # Information is in the file named <base>.git
  git  = os.path.join(base, '.git')
  path = None

  # For this to be a worktree, this must be a file (not a directory)
  if os.path.isfile(git):
    # Read the worktree file
    #    where pathToWorktreeInfo looks like this:
    #    <repoBaseDirectory>/.git/<worktreeSubdirectory>
    try:
      with open(git, 'r') as info:
        # Get the worktree info
        data = info.readline()
        # Should be of the following format:
        #   gitdir: <pathToWorkteeInfo>
        # Error opening or reading from worktree info file
    except OSError:
      raise NotAWorktree(base)
      #DOES NOT RETURN

    # Split off the "gitdir" portion
    data = data.split(' ')
    # There should be exactly 2 items here
    if len(data) != 2:
      raise NotAWorktree(base)
      #DOES NOT RETURN
    # Right side of the split should be of the format
    # "<repoBase>/.git/<worktreeSubdirectory>

    # Split off the repo base
    data = data[1].split('.')
    # There should be exactly 2 items here
    if len(data) != 2:
      raise NotAWorktree(base)
      #DOES NOT RETURN

    # Save repo base
    path = data[0]

  # Not a worktree
  else:
    raise NotAWorktree(base)
    # DOES NOT RETURN

  # Return repo path
  return path[:-1]

# Automatically select a repository
# returns nothing
def AutoSelectRepo(show):
  # Assume no repository is availble
  repo = ''
  # Make sure there is a repository to choose
  if len(data.gbl.repos) > 0:
    print('Autoselecting first available repository')
    repo = data.gbl.repos[0]
    show = True
  # Display change if indicated
  if show:
    print('Selected repo = {0}'.format(repo if repo else None))
  # Set the currently selected repository
  data.gbl.SetItem('repo', repo)

# Find Worktree from partial path
# worktree: Partial pathname of worktree to locate
# retruns   Full pathname or None if not found
def FindWorkTreeFromPartialPath(partial):
  target = partial.lower()
  found  = []
  for worktree in data.gbl.worktrees:   # Loop through worktrees
    match = worktree.lower()
    # See if partial path matches this worktree exactly
    if target.startswith(match):
      return worktree
    # See if partail path is part of worktree
    if target in match:
      found.append(worktree)
  # Was something found?
  if found:
    # Was it ambiguous
    if len(found) > 1:
      raise AmbiguousPartialWorktree(partial)
      # DOES NOT RETURN
    return found[0]
  # If not found in worktrees check repositories
  for repo in data.gbl.repos:          # Loop through repos
    match = repo.lower()
    # See if partial path matches this repo exactly
    if target.startswith(match):
      return repo
    # See if partail path is part of repo
    if target in match:
      found.append(repo)
  # Was something found?
  if found:
    # Was it ambiguous
    if len(found) > 1:
      raise AmbiguousPartialWorktree(partial)
      # DOES NOT RETURN
    return found[0]
  # Nothing found!
  return None

# Set indicated directory as current worktree
# worktree: Directory to become current worktree
# retruns   nothing
def SetWorktree(worktree):
  data.gbl.worktree = worktree
  data.info         = __FindVCS(data.gbl.repos + data.gbl.worktrees, worktree)
  data.gbl.vcs      = gitVCS(worktree) if data.info.VCS().Name() == 'git' else svnVCS(worktree) # Initialize VCS object
  lclDir            = os.path.join(data.gbl.worktree, '.bt')    # Initialize
  data.lcl          = data.BIOSSettings(lclDir, 'local.txt')    #   local settings
  # Handle auto-repo-selection
  repo = worktree if data.info.IsRepo() else GetRepoFromWorktree(worktree)
  repo = FixPath(repo.lower())
  if not data.gbl.repo == repo:
    data.gbl.repo = repo
    print('Repo - {0}: {1}'.format(data.gbl.vcs.Name(), repo))
    if not data.info.IsRepo():
      print('Worktree:   {0}'.format(worktree))
